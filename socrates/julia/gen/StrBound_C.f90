! Autogenerated from Fortran file src/radiance_core/def_bound.F90
! svn revision 1226

module StrBound_C

use, intrinsic :: iso_c_binding

use UTILITIES_CF
use def_bound

implicit none

private

contains

    function create_StrBound() result(bound_Cptr) & 
        bind(C, NAME='PS_create_StrBound')

        implicit none
        type(c_ptr) :: bound_Cptr

        TYPE(StrBound), pointer :: bound

        ALLOCATE(bound)

        bound_Cptr = c_loc(bound)
    end function create_StrBound

    subroutine delete_StrBound(bound_Cptr) &
        bind(C, NAME='PS_delete_StrBound')

        implicit none
        type(c_ptr), value, intent(in) :: bound_Cptr

        TYPE(StrBound), pointer :: bound

        call C_F_POINTER(bound_Cptr, bound)

        DEALLOCATE(bound)

    end subroutine delete_StrBound

    function StrBound_get_integer(bound_Cptr, field_Cstr, val) result(field_OK) &
        bind(C, NAME='PS_StrBound_get_integer')

        implicit none
        type(c_ptr), value, intent(in)          :: bound_Cptr
        type(c_ptr), value, intent(in)          :: field_Cstr
        logical(c_bool)                         :: field_OK
        integer(c_int), intent(out) :: val

        ! local variables
        TYPE(StrBound), pointer                  :: bound
        character(len=:), allocatable           :: field

        ! convert types
        call C_F_POINTER(bound_Cptr, bound)
        field = c_to_f_string(field_Cstr)

        field_OK = .TRUE.
    
        if (field == 'n_brdf_basis_fnc') then
            val = bound%n_brdf_basis_fnc
        else if (field == 'n_point_tile') then
            val = bound%n_point_tile
        else if (field == 'n_tile') then
            val = bound%n_tile
        else
            field_OK = .FALSE.
        end if

    end function StrBound_get_integer

    function StrBound_set_integer(bound_Cptr, field_Cstr, val) result(field_OK) &
        bind(C, NAME='PS_StrBound_set_integer')

        implicit none
        type(c_ptr), value, intent(in)          :: bound_Cptr
        type(c_ptr), value, intent(in)          :: field_Cstr
        logical(c_bool)                         :: field_OK
        integer(c_int), value, intent(in) :: val

        ! local variables
        TYPE(StrBound), pointer                  :: bound
        character(len=:), allocatable           :: field

        ! convert types
        call C_F_POINTER(bound_Cptr, bound)
        field = c_to_f_string(field_Cstr)

        field_OK = .TRUE.
    
        if (field == 'n_brdf_basis_fnc') then
            bound%n_brdf_basis_fnc = val
        else if (field == 'n_point_tile') then
            bound%n_point_tile = val
        else if (field == 'n_tile') then
            bound%n_tile = val
        else
            field_OK = .FALSE.
        end if

    end function StrBound_set_integer

    function StrBound_get_integer_array(bound_Cptr, field_Cstr, loc, dims_C, ndim, lbounds_C) result(field_OK) &
        bind(C, NAME='PS_StrBound_get_integer_array')

        implicit none
        type(c_ptr), value, intent(in)          :: bound_Cptr
        type(c_ptr), value, intent(in)          :: field_Cstr
        logical(c_bool)                         :: field_OK
        type(c_ptr), intent(out)                :: loc
        type(c_ptr), value, intent(in)          :: dims_C
        integer(c_int), intent(inout)           :: ndim
        type(c_ptr), value, intent(in)          :: lbounds_C

        ! local variables
        TYPE(StrBound), pointer             :: bound
        character(len=:), allocatable           :: field
        integer(c_int), pointer, dimension(:)   :: dims, lbounds    

        ! convert types
        call C_F_POINTER(bound_Cptr, bound)
        field = c_to_f_string(field_Cstr)
        call C_F_POINTER(dims_C, dims, [ndim])
        call C_F_POINTER(lbounds_C, lbounds, [ndim])

        field_OK = .TRUE.
    
        if (field == 'list_tile') then
            if (allocated(bound%list_tile)) then
                loc = C_LOC(bound%list_tile)
                ndim = size(shape(bound%list_tile))
                dims(1:ndim) = shape(bound%list_tile)
                lbounds(1:ndim) = lbound(bound%list_tile)
            else
                loc = C_NULL_PTR
            end if

        else
            field_OK = .FALSE.
        end if

    end function StrBound_get_integer_array

    function StrBound_get_real_array(bound_Cptr, field_Cstr, loc, dims_C, ndim, lbounds_C) result(field_OK) &
        bind(C, NAME='PS_StrBound_get_real_array')

        implicit none
        type(c_ptr), value, intent(in)          :: bound_Cptr
        type(c_ptr), value, intent(in)          :: field_Cstr
        logical(c_bool)                         :: field_OK
        type(c_ptr), intent(out)                :: loc
        type(c_ptr), value, intent(in)          :: dims_C
        integer(c_int), intent(inout)           :: ndim
        type(c_ptr), value, intent(in)          :: lbounds_C

        ! local variables
        TYPE(StrBound), pointer             :: bound
        character(len=:), allocatable           :: field
        integer(c_int), pointer, dimension(:)   :: dims, lbounds    

        ! convert types
        call C_F_POINTER(bound_Cptr, bound)
        field = c_to_f_string(field_Cstr)
        call C_F_POINTER(dims_C, dims, [ndim])
        call C_F_POINTER(lbounds_C, lbounds, [ndim])

        field_OK = .TRUE.
    
        if (field == 'zen_0') then
            if (allocated(bound%zen_0)) then
                loc = C_LOC(bound%zen_0)
                ndim = size(shape(bound%zen_0))
                dims(1:ndim) = shape(bound%zen_0)
                lbounds(1:ndim) = lbound(bound%zen_0)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'azim_0') then
            if (allocated(bound%azim_0)) then
                loc = C_LOC(bound%azim_0)
                ndim = size(shape(bound%azim_0))
                dims(1:ndim) = shape(bound%azim_0)
                lbounds(1:ndim) = lbound(bound%azim_0)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'solar_irrad') then
            if (allocated(bound%solar_irrad)) then
                loc = C_LOC(bound%solar_irrad)
                ndim = size(shape(bound%solar_irrad))
                dims(1:ndim) = shape(bound%solar_irrad)
                lbounds(1:ndim) = lbound(bound%solar_irrad)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'lit') then
            if (allocated(bound%lit)) then
                loc = C_LOC(bound%lit)
                ndim = size(shape(bound%lit))
                dims(1:ndim) = shape(bound%lit)
                lbounds(1:ndim) = lbound(bound%lit)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'cos_zen') then
            if (allocated(bound%cos_zen)) then
                loc = C_LOC(bound%cos_zen)
                ndim = size(shape(bound%cos_zen))
                dims(1:ndim) = shape(bound%cos_zen)
                lbounds(1:ndim) = lbound(bound%cos_zen)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'rho_alb') then
            if (allocated(bound%rho_alb)) then
                loc = C_LOC(bound%rho_alb)
                ndim = size(shape(bound%rho_alb))
                dims(1:ndim) = shape(bound%rho_alb)
                lbounds(1:ndim) = lbound(bound%rho_alb)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'f_brdf') then
            if (allocated(bound%f_brdf)) then
                loc = C_LOC(bound%f_brdf)
                ndim = size(shape(bound%f_brdf))
                dims(1:ndim) = shape(bound%f_brdf)
                lbounds(1:ndim) = lbound(bound%f_brdf)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 't_ground') then
            if (allocated(bound%t_ground)) then
                loc = C_LOC(bound%t_ground)
                ndim = size(shape(bound%t_ground))
                dims(1:ndim) = shape(bound%t_ground)
                lbounds(1:ndim) = lbound(bound%t_ground)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'flux_ground') then
            if (allocated(bound%flux_ground)) then
                loc = C_LOC(bound%flux_ground)
                ndim = size(shape(bound%flux_ground))
                dims(1:ndim) = shape(bound%flux_ground)
                lbounds(1:ndim) = lbound(bound%flux_ground)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'orog_corr') then
            if (allocated(bound%orog_corr)) then
                loc = C_LOC(bound%orog_corr)
                ndim = size(shape(bound%orog_corr))
                dims(1:ndim) = shape(bound%orog_corr)
                lbounds(1:ndim) = lbound(bound%orog_corr)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'rho_alb_tile') then
            if (allocated(bound%rho_alb_tile)) then
                loc = C_LOC(bound%rho_alb_tile)
                ndim = size(shape(bound%rho_alb_tile))
                dims(1:ndim) = shape(bound%rho_alb_tile)
                lbounds(1:ndim) = lbound(bound%rho_alb_tile)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'frac_tile') then
            if (allocated(bound%frac_tile)) then
                loc = C_LOC(bound%frac_tile)
                ndim = size(shape(bound%frac_tile))
                dims(1:ndim) = shape(bound%frac_tile)
                lbounds(1:ndim) = lbound(bound%frac_tile)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 't_tile') then
            if (allocated(bound%t_tile)) then
                loc = C_LOC(bound%t_tile)
                ndim = size(shape(bound%t_tile))
                dims(1:ndim) = shape(bound%t_tile)
                lbounds(1:ndim) = lbound(bound%t_tile)
            else
                loc = C_NULL_PTR
            end if

        else if (field == 'flux_tile') then
            if (allocated(bound%flux_tile)) then
                loc = C_LOC(bound%flux_tile)
                ndim = size(shape(bound%flux_tile))
                dims(1:ndim) = shape(bound%flux_tile)
                lbounds(1:ndim) = lbound(bound%flux_tile)
            else
                loc = C_NULL_PTR
            end if

        else
            field_OK = .FALSE.
        end if

    end function StrBound_get_real_array

end module StrBound_C
