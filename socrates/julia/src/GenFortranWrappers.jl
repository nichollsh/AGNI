"""
    GenFortranWrappers

Generate 
    1) ISO_C_BINDING Fortran and Julia wrapper code to access Fortran Type fields (`gen_wrappers`)
    2) Julia modules with const variables corresponding to Fortran module parameters (`gen_pars`)
"""

module GenFortranWrappers

include("ParseFortran.jl")

"""
    gen_wrappers

Generate two files with ISO_C_BINDING Fortran and Julia wrapper code to access Fortran Type fields

`type_fields` is generated by `ParseFortran.parse_type`
"""
function gen_wrappers(
    type_name, type_fields;
    member_name="",
    var_name=lowercase(type_name),
    julia_filename="../gen/$(type_name)$(member_name)_JL.jl",
    lib_name="libSOCRATES_C",
    fortran_module_dependencies=[],
    cfortran_filename="../gen/$(type_name)$(member_name)_C.f90",
    fortran_module_name="$(type_name)$(member_name)_C",
    fortran_realtype="real(realk)",
    fortran_file,
    svn_rev,
)
    gen_julia_wrapper(
        type_name*member_name, type_fields,        
        var_name=var_name,
        ismember=!isempty(member_name),
        julia_filename=julia_filename,
        lib_name=lib_name,
        fortran_realtype=fortran_realtype,
        fortran_file=fortran_file,
        svn_rev=svn_rev,
    )

    gen_cfortran_wrapper(
        type_name, type_fields,
        member_name=member_name,
        var_name=var_name,
        fortran_module_dependencies=fortran_module_dependencies,
        cfortran_filename=cfortran_filename,
        fortran_module_name=fortran_module_name,
        fortran_realtype=fortran_realtype,
        fortran_file=fortran_file,
        svn_rev=svn_rev,
    )

    return nothing
end

###################################
# Julia wrappers
###################################

function gen_julia_wrapper(
    type_name, type_fields;
    var_name=lowercase(type_name),
    ismember,
    julia_filename,
    lib_name,
    fortran_realtype,
    fortran_file,
    svn_rev,
)

    open(julia_filename, "w") do f
        write(f, """
        # Autogenerated from $fortran_file
        # svn revision $svn_rev

        """)

        if !ismember
            write(f, """

                mutable struct $(type_name)
                    cptr::Ptr{Cvoid}

                    function $(type_name)()
                        handle = new(ccall((:PS_create_$(type_name), $lib_name), Ptr{Cvoid}, ()))
                        finalizer(delete_$(type_name), handle)
                        return handle
                    end
                end

                function delete_$(type_name)(handle::$(type_name))
                    if getfield(handle, :cptr) == Ptr{Cvoid}()
                        ccall(:jl_safe_printf, Cvoid, (Cstring, ), "error: delete_$(type_name) attempt to delete null pointer")
                    else
                        ccall((:PS_delete_$(type_name), $lib_name), Cvoid, (Ptr{Cvoid},), getfield(handle, :cptr))
                        setfield!(handle, :cptr, Ptr{Cvoid}())
                    end
                    return nothing
                end

            """)
        else
            write(f, """

                mutable struct $(type_name){P}
                    parent_handle::P
                end

            """)
        end

        write(f, """

            # this is used to show values in the REPL and when using IJulia
            function Base.show(io::IO, m::MIME"text/plain", handle::$(type_name))
                println(io, handle)
                dump_properties(io, handle)                
            end

        """)


        gen_julia_propertynames(f, type_name, type_fields)

        gen_julia_getproperty(
            f, type_name, type_fields, 
            lib_name=lib_name, fortran_realtype=fortran_realtype, ismember=ismember
        )

        gen_julia_setproperty(
            f, type_name, type_fields, 
            lib_name=lib_name, fortran_realtype=fortran_realtype, ismember=ismember
        )

    end
        
    return nothing

end


function gen_julia_propertynames(    
    f::IO, type_name, type_fields
)
    
    write(f, """

        function Base.propertynames(handle::$(type_name), private::Bool=false)
            names = [
    """)
    
    for field in type_fields
        write(f, """
                    :$(field[:name]),
        """)
    end

    write(f, """
            ]

            return names
        end
    
    """)

    return nothing
end

function _gen_julia_cptr(f::IO, ismember::Bool)
    if !ismember
        write(f, """

                cptr = getfield(handle, :cptr)
        """)
    else
        write(f, """

                cptr = getfield(getfield(handle, :parent_handle), :cptr)
        """)
    end

    write(f, """
            cptr != Ptr{Cvoid}() || error("invalid handle (null cptr)")            

    """)
    return nothing
end

function _gen_julia_if(f::IO, fields, firstif)
    firstifstr = firstif ? "if" : "elseif"
    write(f, """
            $firstifstr field in (
    """)
    for fn in fields
        write(f, """
                    :$fn,
        """)
    end
    write(f, """
            )
    """)

    return nothing
end



function gen_julia_getproperty(    
    f::IO, type_name, type_fields;
    fortran_realtype, lib_name, ismember,
)
    
    write(f, """

        function Base.getproperty(handle::$(type_name), field::Symbol)

    """)
    _gen_julia_cptr(f, ismember)

    if !ismember
        write(f, """

                if field == :cptr
                    return cptr

        """)
        firstif = false
    else
        firstif = true
    end

    # logical scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == "logical"]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """            
                    val = Ref{Cuchar}()
                    field_ok = ccall(
                        (:PS_$(type_name)_get_logical, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Ref{Cuchar}),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) logical field \$field not present - coding error")
                    return Bool(val[])
        """)
    end

    # integer scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == "integer"]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """
                    val = Ref{Cint}()
                    field_ok = ccall(
                        (:PS_$(type_name)_get_integer, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Ref{Cint}),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) integer field \$field not present - coding error")
                    return val[]
        """)
    end

    # real scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == fortran_realtype]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """
                    val = Ref{Cdouble}()
                    field_ok = ccall(
                        (:PS_$(type_name)_get_real, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Ref{Cdouble}),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) real field \$field not present - coding error")
                    return val[]
        """)
    end

    function emit_get_array(ctype, ftypename)
        write(f, """
                    loc = Ref{Ptr{$ctype}}()
                    ndim = Ref{Cint}(10)
                    dims = zeros(Cint, ndim[])
                    lbounds = zeros(Cint, ndim[])
                    field_ok = ccall(
                        (:PS_$(type_name)_get_$(ftypename)_array, $lib_name),
                        Cuchar, 
                        (Ptr{Cvoid}, Cstring, Ref{Ptr{$ctype}}, Ref{Cint}, Ref{Cint}, Ref{Cint}),
                        cptr, String(field), loc, dims, ndim, lbounds
                    )
                    Bool(field_ok) || error("$(type_name) $ctype array field \$field not present - coding error")
                    if loc[] == C_NULL
                        return nothing
                    else
                        a = unsafe_wrap(Array, loc[], Tuple(dims[1:ndim[]]), own=false)
                        oa = OffsetArray(a, (lbounds[1:ndim[]] .- 1)...)
                        return oa
                    end
        """)
    end
    # logical arrays returned as OffsetArrays, or nothing if not allocated
    # NB: returned as Cint, not Bool, in order to match layout of 4 byte Fortran logical type
    fields = [f[:name] for f in type_fields if !isempty(f[:dims]) && f[:type] == "logical"]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        emit_get_array("Cint", "logical")
    end

    # integer arrays returned as OffsetArrays, or nothing if not allocated
    fields = [f[:name] for f in type_fields if !isempty(f[:dims]) && f[:type] == "integer"]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        emit_get_array("Cint", "integer")
    end

    # real arrays returned as OffsetArrays, or nothing if not allocated
    fields = [f[:name] for f in type_fields if !isempty(f[:dims]) && f[:type] == fortran_realtype]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        emit_get_array("Cdouble", "real")        
    end

    # strings
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && contains(f[:type], "character")]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """
                    val = zeros(Cuchar, 1024)
                    field_ok = ccall(
                        (:PS_$(type_name)_get_string, $lib_name),
                        Cuchar, 
                        (Ptr{Cvoid}, Cstring, Ptr{Cuchar}, Csize_t),
                        cptr, String(field), val, length(val)
                    )
                    Bool(field_ok) || error("$(type_name) string field \$field not present or truncated")
                    len = findfirst(iszero, val) - 1
                    return rstrip(String(val[1:len]))
        """)
    end

    # Types as members
    # These are returned as a 'subtype' with the handle to the parent object, and the 
    # member of the parent object encoded in 'subtype' = 'type_name*field_name'
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && (f[:type][1:4] == "type")]
    for fieldname in fields
        _gen_julia_if(f, [fieldname], firstif)       
        firstif = false
        write(f, """
                    return $(type_name)$(fieldname)(handle)  
        """)
    end

    if firstif
        write(f, """
                return getfield(handle, field)            
        """)
    else
        write(f, """
                else
                    return getfield(handle, field)
                end    
        """)
    end
    
    write(f, """           
        end
    
    """)

    return nothing
end

function gen_julia_setproperty(    
    f::IO, type_name, type_fields;
    fortran_realtype, lib_name, ismember,
)
    firstif = true
    write(f, """

        function Base.setproperty!(handle::$(type_name), field::Symbol, val)
                  
    """)
    _gen_julia_cptr(f, ismember)

    # logical scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == "logical"]
    if !isempty(fields)        
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """                                
                    field_ok = ccall(
                        (:PS_$(type_name)_set_logical, $lib_name),
                        Cuchar, 
                        (Ptr{Cvoid}, Cstring, Cuchar),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) logical field \$field not present - coding error")
                    return val
        """)
    end

    # integer scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == "integer"]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """                    
                    field_ok = ccall(
                        (:PS_$(type_name)_set_integer, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Cint),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) integer field \$field not present - coding error")
                    return val
        """)
    end

    # real scalars
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && f[:type] == fortran_realtype]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """                    
                    field_ok = ccall(
                        (:PS_$(type_name)_set_real, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Cdouble),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) real field \$field not present - coding error")
                    return val
        """)
    end

    # strings
    fields = [f[:name] for f in type_fields if isempty(f[:dims]) && contains(f[:type], "character")]
    if !isempty(fields)
        _gen_julia_if(f, fields, firstif)       
        firstif = false
        write(f, """                    
                    field_ok = ccall(
                        (:PS_$(type_name)_set_string, $lib_name),
                        Cuchar,
                        (Ptr{Cvoid}, Cstring, Cstring),
                        cptr, String(field), val
                    )
                    Bool(field_ok) || error("$(type_name) string field \$field not present or truncated")
                    return val
        """)
    end

    if firstif
        write(f, """
                error("type $type_name has no writeable field \$field")            
        """)
    else
        write(f, """
                else
                    error("type $type_name has no writeable field \$field")    
                end    
        """)
    end

    write(f, """           
        end
    
    """)

    return nothing
end

###################################
# C Fortran wrappers
###################################

function gen_cfortran_wrapper(
    type_name, type_fields;
    member_name="",
    var_name=lowercase(type_name),
    fortran_module_dependencies=[],
    cfortran_filename="$(type_name)$(membername)_C.f90",
    fortran_module_name="$(type_name)$(membername)_C",
    fortran_realtype,
    fortran_file,
    svn_rev
)

    open(cfortran_filename, "w") do f
        write(f, "! Autogenerated from Fortran file $fortran_file\n")
        write(f, "! svn revision $svn_rev\n")
        write(f, "\n")
        write(f, "module $fortran_module_name\n")
        write(f, "\n")
        write(f, "use, intrinsic :: iso_c_binding\n")
        write(f, "\n")
        write(f, "use UTILITIES_CF\n")
        for d in fortran_module_dependencies
            write(f, "use $d\n")
        end
        write(f, "\n")
        write(f, "implicit none\n")
        write(f, "\n")
        write(f, "private\n")
        write(f, "\n")
        write(f, "contains\n")
        write(f, "\n")

        if isempty(member_name)
            gen_cfortran_create(f, type_name, var_name=var_name)
            gen_cfortran_delete(f, type_name, var_name=var_name)
        end

        gen_cfortran_get(f, type_name, type_fields, "logical", "c_bool", var_name=var_name, member_name=member_name)
        gen_cfortran_set(f, type_name, type_fields, "logical", "c_bool", var_name=var_name, member_name=member_name)

        gen_cfortran_get(f, type_name, type_fields, "integer", "c_int", var_name=var_name, member_name=member_name)
        gen_cfortran_set(f, type_name, type_fields, "integer", "c_int", var_name=var_name, member_name=member_name)

        gen_cfortran_get(
            f, type_name, type_fields, fortran_realtype, "c_double", 
            var_name=var_name, ftype_emit_fortran="real", member_name=member_name
        )
        gen_cfortran_set(
            f, type_name, type_fields, fortran_realtype, "c_double", 
            var_name=var_name, ftype_emit_fortran="real", member_name=member_name
        )

        gen_cfortran_get_array(f, type_name, type_fields, "logical", var_name=var_name, member_name=member_name)
        gen_cfortran_get_array(f, type_name, type_fields, "integer", var_name=var_name, member_name=member_name)
        gen_cfortran_get_array(
            f, type_name, type_fields, fortran_realtype, 
            var_name=var_name, ftype_emit_fortran="real", member_name=member_name
        )

        gen_cfortran_get_string(f, type_name, type_fields, var_name=var_name, member_name=member_name)
        gen_cfortran_set_string(f, type_name, type_fields, var_name=var_name, member_name=member_name)

        write(f, "end module $fortran_module_name\n")
    end

end


function gen_cfortran_create(
    f::IO, type_name;
    var_name=type_name
)

    write(f, """
        function create_$type_name() result($(var_name)_Cptr) & 
            bind(C, NAME='PS_create_$type_name')

            implicit none
            type(c_ptr) :: $(var_name)_Cptr

            TYPE($type_name), pointer :: $var_name

            ALLOCATE($var_name)

            $(var_name)_Cptr = c_loc($var_name)
        end function create_$type_name
    
    """)
    return nothing
end

function gen_cfortran_delete(
    f::IO, type_name;
    var_name=type_name
)

    write(f, """
        subroutine delete_$type_name($(var_name)_Cptr) &
            bind(C, NAME='PS_delete_$type_name')

            implicit none
            type(c_ptr), value, intent(in) :: $(var_name)_Cptr

            TYPE($type_name), pointer :: $(var_name)

            call C_F_POINTER($(var_name)_Cptr, $(var_name))

            DEALLOCATE($(var_name))

        end subroutine delete_$type_name
    
    """)
    return nothing
end

function gen_cfortran_get(
    f::IO, type_name, type_fields, ftype_match_fortran, ftype_c;
    var_name=type_name,
    ftype_emit_fortran=ftype_match_fortran,
    member_name="",
)

    type_fields_filtered = [x for x in type_fields if isempty(x[:dims]) && (x[:type]==lowercase(ftype_match_fortran))]

    if isempty(type_fields_filtered)
        return
    end

    write(f, """
        function $(type_name)$(member_name)_get_$(ftype_emit_fortran)($(var_name)_Cptr, field_Cstr, val) result(field_OK) &
            bind(C, NAME='PS_$(type_name)$(member_name)_get_$(ftype_emit_fortran)')

            implicit none
            type(c_ptr), value, intent(in)          :: $(var_name)_Cptr
            type(c_ptr), value, intent(in)          :: field_Cstr
            logical(c_bool)                         :: field_OK
            $(ftype_emit_fortran)($ftype_c), intent(out) :: val

            ! local variables
            TYPE($(type_name)), pointer                  :: $(var_name)
            character(len=:), allocatable           :: field

            ! convert types
            call C_F_POINTER($(var_name)_Cptr, $(var_name))
            field = c_to_f_string(field_Cstr)

            field_OK = .TRUE.
        
    """)

    first_field = true
    for field in type_fields_filtered

        ifstr = first_field ? "if" : "else if"
        fn = isempty(member_name) ? field[:name] : "$member_name%$(field[:name])" 
        write(f, """
                $ifstr (field == '$(field[:name])') then
                    val = $(var_name)%$fn
        """)
        first_field = false
    end
    write(f, """
            else
                field_OK = .FALSE.
            end if
    
        end function $(type_name)$(member_name)_get_$(ftype_emit_fortran)
    
    """)

    return nothing
end


function gen_cfortran_set(
    f::IO, type_name, type_fields, ftype_match_fortran, ftype_c;
    var_name=type_name,
    ftype_emit_fortran=ftype_match_fortran,
    member_name="",
)

    type_fields_filtered = [x for x in type_fields if isempty(x[:dims]) && (x[:type]==lowercase(ftype_match_fortran))]

    if isempty(type_fields_filtered)
        return
    end

    write(f, """
        function $(type_name)$(member_name)_set_$(ftype_emit_fortran)($(var_name)_Cptr, field_Cstr, val) result(field_OK) &
            bind(C, NAME='PS_$(type_name)$(member_name)_set_$(ftype_emit_fortran)')

            implicit none
            type(c_ptr), value, intent(in)          :: $(var_name)_Cptr
            type(c_ptr), value, intent(in)          :: field_Cstr
            logical(c_bool)                         :: field_OK
            $(ftype_emit_fortran)($ftype_c), value, intent(in) :: val

            ! local variables
            TYPE($(type_name)), pointer                  :: $(var_name)
            character(len=:), allocatable           :: field

            ! convert types
            call C_F_POINTER($(var_name)_Cptr, $(var_name))
            field = c_to_f_string(field_Cstr)

            field_OK = .TRUE.
        
    """)

    first_field = true
    for field in type_fields_filtered

        ifstr = first_field ? "if" : "else if"
        fn = isempty(member_name) ? field[:name] : "$member_name%$(field[:name])" 
        write(f, """
                $ifstr (field == '$(field[:name])') then
                    $(var_name)%$fn = val
        """)
        first_field = false
    end
    
    write(f, """
            else
                field_OK = .FALSE.
            end if
    
        end function $(type_name)$(member_name)_set_$(ftype_emit_fortran)
    
    """)

    return nothing
end

function gen_cfortran_get_array(
    f::IO, type_name, type_fields, ftype_match_fortran;
    var_name=type_name,
    ftype_emit_fortran=ftype_match_fortran,
    member_name="",
)

    type_fields_filtered = [x for x in type_fields if !isempty(x[:dims]) && (x[:type]==lowercase(ftype_match_fortran))]

    if isempty(type_fields_filtered)
        return
    end

    write(f, """
        function $(type_name)$(member_name)_get_$(ftype_emit_fortran)_array($(var_name)_Cptr, field_Cstr, loc, dims_C, ndim, lbounds_C) result(field_OK) &
            bind(C, NAME='PS_$(type_name)$(member_name)_get_$(ftype_emit_fortran)_array')

            implicit none
            type(c_ptr), value, intent(in)          :: $(var_name)_Cptr
            type(c_ptr), value, intent(in)          :: field_Cstr
            logical(c_bool)                         :: field_OK
            type(c_ptr), intent(out)                :: loc
            type(c_ptr), value, intent(in)          :: dims_C
            integer(c_int), intent(inout)           :: ndim
            type(c_ptr), value, intent(in)          :: lbounds_C

            ! local variables
            TYPE($(type_name)), pointer             :: $(var_name)
            character(len=:), allocatable           :: field
            integer(c_int), pointer, dimension(:)   :: dims, lbounds    

            ! convert types
            call C_F_POINTER($(var_name)_Cptr, $(var_name))
            field = c_to_f_string(field_Cstr)
            call C_F_POINTER(dims_C, dims, [ndim])
            call C_F_POINTER(lbounds_C, lbounds, [ndim])

            field_OK = .TRUE.
        
    """)

    first_field = true
    for field in type_fields_filtered

        ifstr = first_field ? "if" : "else if"
        fn = isempty(member_name) ? field[:name] : "$member_name%$(field[:name])" 
        write(f, """
                $ifstr (field == '$(field[:name])') then
                    if (allocated($(var_name)%$fn)) then
                        loc = C_LOC($(var_name)%$fn)
                        ndim = size(shape($(var_name)%$fn))
                        dims(1:ndim) = shape($(var_name)%$fn)
                        lbounds(1:ndim) = lbound($(var_name)%$fn)
                    else
                        loc = C_NULL_PTR
                    end if

        """)
        first_field = false
    end
    write(f, """
            else
                field_OK = .FALSE.
            end if
    
        end function $(type_name)$(member_name)_get_$(ftype_emit_fortran)_array
    
    """)

    return nothing
end

function gen_cfortran_get_string(
    f::IO, type_name, type_fields;
    var_name=type_name,
    member_name="",
)

    type_fields_filtered = [x for x in type_fields if isempty(x[:dims]) && contains(x[:type], "character")]

    if isempty(type_fields_filtered)
        return
    end

    write(f, """
        function $(type_name)$(member_name)_get_string($(var_name)_Cptr, field_Cstr, val, val_len) result(field_OK) &
            bind(C, NAME='PS_$(type_name)$(member_name)_get_string')

            implicit none
            type(c_ptr), value, intent(in)          :: $(var_name)_Cptr
            type(c_ptr), value, intent(in)          :: field_Cstr
            logical(c_bool)                         :: field_OK
            type(c_ptr), value, intent(in)          :: val
            integer(c_size_t), value, intent(in)    :: val_len 

            ! local variables
            TYPE($(type_name)), pointer             :: $(var_name)
            character(len=:), allocatable           :: field
           
            ! convert types
            call C_F_POINTER($(var_name)_Cptr, $(var_name))
            field = c_to_f_string(field_Cstr)
                    
            field_OK = .TRUE.
        
    """)

    first_field = true
    for field in type_fields_filtered

        ifstr = first_field ? "if" : "else if"
        fn = isempty(member_name) ? field[:name] : "$member_name%$(field[:name])" 
        write(f, """
                $ifstr (field == '$(field[:name])') then                    
                    field_OK = copy_f_to_c_string(val, val_len, $(var_name)%$fn)
        """)
        first_field = false
    end
    write(f, """
            else
                field_OK = .FALSE.
            end if
    
        end function $(type_name)$(member_name)_get_string
    
    """)

    return nothing
end

function gen_cfortran_set_string(
    f::IO, type_name, type_fields;
    var_name=type_name,
    member_name="",
)

    type_fields_filtered = [x for x in type_fields if isempty(x[:dims]) && contains(x[:type], "character")]

    if isempty(type_fields_filtered)
        return
    end

    write(f, """
        function $(type_name)$(member_name)_set_string($(var_name)_Cptr, field_Cstr, val) result(field_OK) &
            bind(C, NAME='PS_$(type_name)$(member_name)_set_string')

            implicit none
            type(c_ptr), value, intent(in)          :: $(var_name)_Cptr
            type(c_ptr), value, intent(in)          :: field_Cstr
            logical(c_bool)                         :: field_OK
            type(c_ptr), value, intent(in)          :: val
           

            ! local variables
            TYPE($(type_name)), pointer             :: $(var_name)
            character(len=:), allocatable           :: field            

            ! convert types
            call C_F_POINTER($(var_name)_Cptr, $(var_name))
            field = c_to_f_string(field_Cstr)
                    
            field_OK = .TRUE.
        
    """)

    first_field = true
    for field in type_fields_filtered

        ifstr = first_field ? "if" : "else if"
        fn = isempty(member_name) ? field[:name] : "$member_name%$(field[:name])" 
        write(f, """
                $ifstr (field == '$(field[:name])') then                    
                    field_OK = copy_c_to_f_string($(var_name)%$fn, val)
        """)
        first_field = false
    end
    write(f, """
            else
                field_OK = .FALSE.
            end if
    
        end function $(type_name)$(member_name)_set_string
    
    """)

    return nothing
end

#####################################################################
# Generate Julia module with Fortran module parameters -> Julia module consts
#####################################################################

"""
    gen_pars(julia_filename, julia_modulename, parameter_fields;
        fortran_file, svn_rev)

Generate a Julia module `julia_modulename` containing Julia const variables
corresponding to Fortran parameter variables supplied in `parameter_fields`.

`parameter_fields` is generated by `ParseFortran.parse_module_parameters`
"""
function gen_pars(
    julia_filename, julia_modulename, parameter_fields;
    fortran_file, svn_rev)
    
    open(julia_filename, "w") do f
        write(f, """
        # Autogenerated from $fortran_file
        # svn revision $svn_rev

        module $(julia_modulename)
        

        """)

        for pf in parameter_fields
            initializer_jl = juliaize_initializer(pf[:initializer])
            if !(initializer_jl isa AbstractVector)
                write(f, """

                const $(pf[:name]) = $(pf[:initializer])
                """)
            else
                write(f, """

                const $(pf[:name]) = [
                """)
                for ji in initializer_jl
                    write(f, """
                        $ji,
                    """) 
                end
                write(f, """
                ]
                """)
            end           
        end
        write(f, """

        end
        """)
    end        
end

"convert a Fortran scalar initializer into a Julia initializer"
function juliaize_scalar_initializer(initializer::AbstractString)
    if length(initializer) >= 2 && 
        ((initializer[1] == '"' && initializer[end] == '"') ||
        (initializer[1] == ''' && initializer[end] == '''))
        # string - strip Fortran trailing blanks
        initializer = '"'*rstrip(initializer[2:end-2])*'"'
    else
        # strip off any _RealK etc suffix
        initializer= split(initializer, "_")[1]
    end
    return initializer
end

"split a Fortran initializer into a Julia Vector, handling cases where a string element includes ,"
function safe_split(str)
    strsplitnaive = split(str, ",")
    if lstrip(strsplitnaive[1])[1] in (''', '"')
        # reassemble any strings containing ,
        strsplit = []        
        for str in strsplitnaive
            if !(lstrip(str)[1] in (''', '"'))               
                strsplit[end] = strsplit[end]*","*str
            else
                push!(strsplit, str)
            end
        end
    else
        # not strings
        strsplit = strsplitnaive
    end

    return strsplit
end

"convert a parameter initializer string parsed from Fortran to a Julia const variable initializer"
function juliaize_initializer(initializer)
    if length(initializer) > 4 && initializer[1:2] == "(/" && initializer[end-1:end] == "/)"
        initializer = juliaize_scalar_initializer.(strip.(safe_split(initializer[3:end-2])))
    else
        initializer = juliaize_scalar_initializer(initializer)
    end
    return initializer
end

end
